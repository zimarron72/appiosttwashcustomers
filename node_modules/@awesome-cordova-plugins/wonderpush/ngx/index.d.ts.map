{"version":3,"file":"index.d.ts","sources":["index.d.ts"],"names":[],"mappings":"AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA","sourcesContent":["import { AwesomeCordovaNativePlugin } from '@awesome-cordova-plugins/core';\nexport interface WonderPushDelegate {\n    urlForDeepLink(url: string, callback: (url?: string) => void): void;\n}\nexport interface WonderPushChannel {\n    id: string;\n    groupId?: string;\n    name?: string;\n    description?: string;\n    bypassDnd?: boolean;\n    showBadge?: boolean;\n    importance?: number;\n    lights?: boolean;\n    lightColor?: number;\n    vibrate?: boolean;\n    sound?: boolean;\n    soundUri?: string;\n    lockscreenVisibility?: number;\n    vibrateInSilentMode?: boolean;\n    color?: number;\n    localOnly?: boolean;\n}\nexport interface WonderPushChannelGroup {\n    id: string;\n    name?: string;\n}\ndeclare class NestedObject {\n    pluginObj: any;\n    constructor(pluginObj: any);\n    wrap<T>(functionName: string, args: any[]): Promise<T>;\n}\nexport declare class UserPreferencesMethods extends NestedObject {\n    /**\n     * Get the default channel id\n     *\n     * @returns {Promise<string>}\n     */\n    getDefaultChannelId(): Promise<string>;\n    /**\n     * Set the default channel id\n     *\n     * @param {string} id\n     * @returns {Promise<any>}\n     */\n    setDefaultChannelId(id: string): Promise<any>;\n    /**\n     * Get a channel group\n     *\n     * @param {string} groupId\n     * @returns {Promise<WonderPushChannelGroup | null>}\n     */\n    getChannelGroup(groupId: string): Promise<WonderPushChannelGroup | null>;\n    /**\n     * Get a channel\n     *\n     * @param {string} channelId\n     * @returns {Promise<WonderPushChannel | null>}\n     */\n    getChannel(channelId: string): Promise<WonderPushChannel | null>;\n    /**\n     * Create, update and remove channel existing groups to match the given channel groups\n     *\n     * @param {WonderPushChannelGroup[]} channelGroups\n     * @returns {Promise<any>}\n     */\n    setChannelGroups(channelGroups: WonderPushChannelGroup[]): Promise<any>;\n    /**\n     * Create, update and remove channels to match the given channels\n     *\n     * @param {WonderPushChannel[]} channels\n     * @returns {Promise<any>}\n     */\n    setChannels(channels: WonderPushChannel[]): Promise<any>;\n    /**\n     * Create or update a channel group\n     *\n     * @param {WonderPushChannelGroup} channelGroup\n     * @returns {Promise<any>}\n     */\n    putChannelGroup(channelGroup: WonderPushChannelGroup): Promise<any>;\n    /**\n     * Create or update a channel\n     *\n     * @param {WonderPushChannel} channel\n     * @returns {Promise<any>}\n     */\n    putChannel(channel: WonderPushChannel): Promise<any>;\n    /**\n     * Remove a channel group\n     *\n     * @param {string} groupId\n     * @returns {Promise<any>}\n     */\n    removeChannelGroup(groupId: string): Promise<any>;\n    /**\n     * Remove a channel\n     *\n     * @param {string} channelId\n     * @returns {Promise<any>}\n     */\n    removeChannel(channelId: string): Promise<any>;\n}\n/**\n * @name Push Notifications - WonderPush\n * @description\n *\n * Send unlimited push notifications to iOS and Android devices.\n *\n * Get started in minutes: [Ionic Quickstart Guide](https://docs.wonderpush.com/docs/ionic-quickstart).\n *\n * Advanced segmentation, automation and personalization of push messages for â‚¬1 per 1000 subscribers.\n *\n * Requires the Cordova plugin `wonderpush-cordova-sdk`.\n *\n * [WonderPush push notifications](https://www.wonderpush.com) are the most effective way\n * to retain your users and grow your audience while remaining fully GDPR compliant.\n * @usage\n * ```typescript\n * import { WonderPush } from '@awesome-cordova-plugins/wonderpush';\n *\n *\n * constructor(private wonderPush: WonderPush) { }\n *\n * ...\n *\n * // Subscribe user\n * this.wonderPush.subscribeToNotifications()\n *   .then(() => console.log(\"User subscribed to notifications\"))\n *   .catch((error: any) => console.error(error));\n *\n *\n * // Send an event (a purchase in this example)\n * this.wonderPush.sendEvent('purchase', {\n *   float_price: 12.99,\n *   string_sku: \"X123456\"\n * });\n *\n * // Tag users (as customers)\n * this.wonderPush.addTag('customer');\n *\n * // Personalize\n * // 1. Store user details.\n * // 2. Use those details to create segments.\n * // 3. Include those details in your notifications.\n * this.wonderPush.putProperties({\n *   string_name: 'John D.',\n *   int_age: 24\n * });\n *\n * // GDPR\n * // 1. set REQUIRES_USER_CONSENT=true to enable GDPR compliance.\n * // 2. WonderPush doesn't start until setUserConsent(true) is called.\n * const onClick = (userConsent: boolean) => this.wonderPush.setUserConsent(userConsent);\n *\n * // Listen to notification clicks\n * document.addEventListener('wonderpush.notificationOpen', function(event) {\n *   console.log('Notification opened', event.notification);\n *   if (event.notificationType === 'data') {\n *     console.log('Silent notification', event.notification);\n *   }\n * });\n * ```\n * @interfaces\n * WonderPushChannel\n * WonderPushChannelGroup\n */\nexport declare class WonderPush extends AwesomeCordovaNativePlugin {\n    /**\n     * Sets the user id, used to identify a single identity across multiple devices,\n     * and to correctly identify multiple users on a single device.\n     *\n     * If not called, the last used user id it assumed. Defaulting to `null` if none is known.\n     *\n     * Upon changing userId, the access token is wiped, so avoid unnecessary calls, like calling with `null`\n     * just before calling with a user id.\n     *\n     * @param {?string} userId - The user id, unique to your application.\n     *   Use `null` for anonymous users.\n     *\n     *   You are strongly encouraged to use your own unique internal identifier.\n     * @returns {Promise<any>}\n     */\n    setUserId(userId: string | null): Promise<any>;\n    /**\n     * Controls native SDK logging.\n     *\n     * @param {boolean} enabled - Whether to enable logs.\n     * @returns {Promise<any>}\n     */\n    setLogging(enabled: boolean): Promise<any>;\n    /**\n     * Sets up a delegate for tighter integration, or removes it.\n     *\n     * @param {?WonderPushDelegate} delegate - The delegate to set, or `null` to remove it.\n     * @returns {Promise<any>}\n     */\n    setDelegate(delegate: WonderPushDelegate | null): Promise<any>;\n    /**\n     * Gets the current delegate.\n     *\n     * @returns {Promise<WonderPushDelegate | null>} A promise with the delegate of null\n     */\n    getDelegate(): Promise<WonderPushDelegate | null>;\n    /**\n     * Returns the userId currently in use, `null` by default.\n     *\n     * @returns {Promise<string | null>} A promise with the user ID or null\n     */\n    getUserId(): Promise<string | null>;\n    /**\n     * Returns the installationId identifying your application on a device, bond to a specific userId.\n     * If you want to store this information on your servers, keep the corresponding userId with it.\n     * Will return `null` until the SDK is properly initialized.\n     *\n     * @returns {Promise<string | null>} A promise with the installation ID or null\n     */\n    getInstallationId(): Promise<string | null>;\n    /**\n     * Returns the unique device identifier\n     *\n     * @returns {Promise<string | null>} A promise with the device ID or null\n     */\n    getDeviceId(): Promise<string | null>;\n    /**\n     * Returns the push token.\n     *\n     * @returns {Promise<string | null>} A promise with the push token or `null`\n     */\n    getPushToken(): Promise<string | null>;\n    /**\n     * Returns the currently used access token.\n     * Returns `null` until the SDK is properly initialized.\n     * This together with your client secret gives entire control to the current installation and associated user, you should not disclose it unnecessarily.\n     *\n     * @returns {Promise<string | null>}\n     */\n    getAccessToken(): Promise<string | null>;\n    /**\n     * Send an event to be tracked to WonderPush.\n     *\n     * @param {string} type - The event type, or name. Event types starting with an `@` character are reserved.\n     * @param {?object} [attributes] - An object containing custom properties to be attached to the event.\n     *   The keys should be prefixed according to the type of their values.\n     *   You can find the details in the [Concepts > Custom fields](https://www.wonderpush.com/docs/guide/custom-fields) section of the documentation.\n     * @returns {Promise<any>}\n     */\n    trackEvent(type: string, attributes: {\n        [key: string]: any;\n    }): Promise<any>;\n    /**\n     * Adds one or more tags to the installation.\n     *\n     * @param {string|string[]} tag - The tags to add to the installation. You can use either a single string argument or an array of strings.\n     * @returns {Promise<any>}\n     */\n    addTag(tag: string | string[]): Promise<any>;\n    /**\n     * Removes one or more tags from the installation.\n     *\n     * @param {string|string[]} tag - The tags to remove from the installation. You can use either a single string argument or an array of strings.\n     * @returns {Promise<any>}\n     */\n    removeTag(tag: string | string[]): Promise<any>;\n    /**\n     * Removes all tags from the installation.\n     *\n     * @returns {Promise<any>}\n     */\n    removeAllTags(): Promise<any>;\n    /**\n     * Returns all the tags of the installation.\n     *\n     * @returns {Promise<string[]>}\n     */\n    getTags(): Promise<string[]>;\n    /**\n     * Tests whether the installation has the given tag attached to it.\n     *\n     * @param {string} tag - The tag to test.\n     * @returns {Promise<boolean>}\n     */\n    hasTag(tag: string): Promise<boolean>;\n    /**\n     * Sets the value to a given installation property.\n     *\n     * The previous value is replaced entirely.\n     * Setting `undefined` or `null` has the same effect as {@link cordova.plugins.WonderPush#unsetProperty}.\n     *\n     * @param {string} field - The name of the property to set\n     * @param value\n     * @returns {Promise<any>}\n     */\n    setProperty(field: string, value: any): Promise<any>;\n    /**\n     * Removes the value of a given installation property.\n     *\n     * The previous value is replaced with `null`.\n     *\n     * @param {string} field - The name of the property\n     * @returns {Promise<any>}\n     */\n    unsetProperty(field: string): Promise<any>;\n    /**\n     * Adds the value to a given installation property.\n     *\n     * The stored value is made an array if not already one.\n     * If the given value is an array, all its values are added.\n     * If a value is already present in the stored value, it won't be added.\n     *\n     * @param {string} field - The name of the property\n     * @param value\n     * @returns {Promise<void>}\n     */\n    addProperty(field: string, value: any): Promise<void>;\n    /**\n     * Removes the value from a given installation property.\n     *\n     * The stored value is made an array if not already one.\n     * If the given value is an array, all its values are removed.\n     * If a value is present multiple times in the stored value, they will all be removed.\n     *\n     * @param {string} field - The name of the property\n     * @param value\n     * @returns {Promise<any>}\n     */\n    removeProperty(field: string, value: any): Promise<any>;\n    /**\n     * Returns the value of a given installation property.\n     *\n     * If the property stores an array, only the first value is returned.\n     * This way you don't have to deal with potential arrays if that property is not supposed to hold one.\n     * Returns `null` if the property is absent or has an empty array value.\n     *\n     * @param {string} field - The name of the property to read values from\n     * @returns {Promise<any>}\n     */\n    getPropertyValue(field: string): Promise<any>;\n    /**\n     * Returns an array of the values of a given installation property.\n     *\n     * If the property does not store an array, an array is returned nevertheless.\n     * This way you don't have to deal with potential scalar values if that property is supposed to hold an array.\n     * Returns an empty array instead of `null` if the property is absent.\n     * Returns an array wrapping any scalar value held by the property.\n     *\n     * @param {string} field - The name of the property to read values from\n     * @returns {Promise<any[]>}\n     */\n    getPropertyValues(field: string): Promise<any[]>;\n    /**\n     * Returns the latest known custom properties attached to the current installation object stored by WonderPush.\n     *\n     * @returns {Promise<{[p: string]: any}>}\n     */\n    getProperties(): Promise<{\n        [key: string]: any;\n    }>;\n    /**\n     * Updates the properties attached to the current installation object stored by WonderPush.\n     *\n     * In order to remove a value, use `null`.\n     *\n     * @param {{[p: string]: any}} properties. The keys should be prefixed according to the type of their values. You can find the details in the [Segmentation > Properties](https://docs.wonderpush.com/docs/properties#section-custom-properties) section of the documentation.\n     * @returns {Promise<any>}\n     */\n    putProperties(properties: {\n        [key: string]: any;\n    }): Promise<any>;\n    /**\n     * Subscribes to push notification and registers the device token with WondePush.\n     *\n     * On iOS, you **must** call the following method at least once to make the notification visible to the user.\n     *\n     * - You can call this method multiple times. The user is only prompted for permission by iOS once.\n     * - There is no need to call this method if the permission has already been granted, but it does not harm either.\n     * - If the permission has been denied in the OS, the user will stay soft opt-out.\n     *\n     * Because in iOS you only have *one* chance for prompting the user, you should find a good timing for that.\n     * For a start, you can systematically call it when the application starts, so that the user will be prompted directly at the first launch.\n     *\n     * @returns {Promise<any>} Returns a promise that resolves upon successful subscription\n     */\n    subscribeToNotifications(): Promise<any>;\n    /**\n     * Returns whether the notifications are enabled.\n     *\n     * @returns {Promise<boolean>}\n     */\n    isSubscribedToNotifications(): Promise<boolean>;\n    /**\n     * Unsubscribes from push notification.\n     * This method marks the user as soft opt-out.\n     *\n     * @returns {Promise<any>}\n     */\n    unsubscribeFromNotifications(): Promise<any>;\n    /**\n     * Reads user consent state.\n     * Returns undefined if no explicit consent was set.\n     *\n     * @returns {Promise<boolean>}\n     */\n    getUserConsent(): Promise<boolean>;\n    /**\n     * Provides or withdraws user consent.\n     * If the `requiresUserConsent` initialization option is true,\n     * the whole SDK is paused and no data is sent to WonderPush, until consent is provided.\n     *\n     * @param {boolean} consent -\n     * @returns {Promise<any>}\n     */\n    setUserConsent(consent: boolean): Promise<any>;\n    /**\n     * Remove any local storage and ask the WonderPush servers to delete any data associated with the all local installations and related users.\n     *\n     * @returns {Promise<any>}\n     */\n    clearAllData(): Promise<any>;\n    /**\n     * Ask the WonderPush servers to delete any event associated with the all local installations.\n     *\n     * @returns {Promise<any>}\n     */\n    clearEventsHistory(): Promise<any>;\n    /**\n     * Ask the WonderPush servers to delete any custom data associated with the all local installations and related users.\n     *\n     * @returns {Promise<any>}\n     */\n    clearPreferences(): Promise<any>;\n    /**\n     * Initiates the download of all user remote and local data.\n     *\n     * @returns {Promise<any>}\n     */\n    downloadAllData(): Promise<any>;\n    UserPreferences: UserPreferencesMethods;\n}\nexport {};\n"]}